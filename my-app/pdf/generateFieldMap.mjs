// generateFieldMap.mjs
// Reads mapper JSON (fieldMap.partial.json) that now includes { pageIndex, x, y, direction }
// Generates fieldMap.ts that includes direction?: "auto" | "ltr" | "rtl"

import { readFile, writeFile } from "node:fs/promises";

function parseArgs(argv) {
  const args = {};
  for (const a of argv.slice(2)) {
    if (!a.startsWith("--")) continue;
    const [k, v] = a.split("=");
    args[k] = v === undefined ? true : v;
  }
  return args;
}

function toNum(v) {
  if (v === undefined || v === null || v === true) return undefined;
  const n = Number(v);
  return Number.isFinite(n) ? n : undefined;
}

function toBool(v) {
  if (v === undefined || v === null) return undefined;
  if (v === true || v === false) return v;
  if (typeof v === "string") return v.toLowerCase() === "true";
  return undefined;
}

function escapeTsString(s) {
  return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function stableEntries(obj) {
  return Object.entries(obj).sort(([a], [b]) => a.localeCompare(b));
}

function normalizeDirection(v) {
  if (v === "rtl" || v === "ltr" || v === "auto") return v;
  return undefined;
}

function fieldMapToTs(fieldMap) {
  const lines = [];

  lines.push(`// AUTO-GENERATED by generateFieldMap.mjs`);
  lines.push(`// Edit per-field properties here (width/fontSize/etc)`);
  lines.push(``);
  lines.push(`export type Direction = "auto" | "ltr" | "rtl";`);
  lines.push(``);
  lines.push(`export type FieldSpec = {`);
  lines.push(`  pageIndex: number;`);
  lines.push(`  x: number;`);
  lines.push(`  y: number;`);
  lines.push(`  direction?: Direction;`);
  lines.push(`  width?: number;`);
  lines.push(`  height?: number;`);
  lines.push(`  fontSize?: number;`);
  lines.push(`  lineHeight?: number;`);
  lines.push(`  align?: "left" | "center" | "right";`);
  lines.push(`  maxFontSize?: number;`);
  lines.push(`  minFontSize?: number;`);
  lines.push(`  clearBackground?: boolean;`);
  lines.push(`};`);
  lines.push(``);
  lines.push(`export type FieldMap = Record<string, FieldSpec>;`);
  lines.push(``);
  lines.push(`export const fieldMap: FieldMap = {`);

  for (const [name, spec] of stableEntries(fieldMap)) {
    const parts = [
      `pageIndex: ${spec.pageIndex}`,
      `x: ${spec.x}`,
      `y: ${spec.y}`,
    ];

    if (spec.direction !== undefined) parts.push(`direction: "${spec.direction}"`);
    if (spec.width !== undefined) parts.push(`width: ${spec.width}`);
    if (spec.height !== undefined) parts.push(`height: ${spec.height}`);
    if (spec.fontSize !== undefined) parts.push(`fontSize: ${spec.fontSize}`);
    if (spec.lineHeight !== undefined) parts.push(`lineHeight: ${spec.lineHeight}`);
    if (spec.align !== undefined) parts.push(`align: "${spec.align}"`);
    if (spec.maxFontSize !== undefined) parts.push(`maxFontSize: ${spec.maxFontSize}`);
    if (spec.minFontSize !== undefined) parts.push(`minFontSize: ${spec.minFontSize}`);
    if (spec.clearBackground !== undefined) parts.push(`clearBackground: ${spec.clearBackground}`);

    lines.push(`  "${escapeTsString(name)}": { ${parts.join(", ")} },`);
  }

  lines.push(`};`);
  lines.push(``);
  return lines.join("\n");
}

async function main() {
  const args = parseArgs(process.argv);

  const inPath = String(args["--in"] ?? "fieldMap.partial.json");
  const outPath = String(args["--out"] ?? "fieldMap.ts");

  // Default direction behavior:
  // - If the mapper saved direction per-field, we keep it.
  // - Otherwise, you can force a default with --direction=rtl|ltr|auto
  const defaultDirection = normalizeDirection(args["--direction"]);

  const defaults = {
    direction: defaultDirection, // only applied if input didn't include direction
    width: toNum(args["--width"]),
    height: toNum(args["--height"]),
    fontSize: toNum(args["--fontSize"]) ?? 12,
    lineHeight: toNum(args["--lineHeight"]),
    align: typeof args["--align"] === "string" ? args["--align"] : undefined,
    maxFontSize: toNum(args["--maxFontSize"]),
    minFontSize: toNum(args["--minFontSize"]),
    clearBackground: toBool(args["--clearBackground"]) ?? true,
  };

  const raw = await readFile(inPath, "utf8");
  const points = JSON.parse(raw);

  if (!points || typeof points !== "object" || Array.isArray(points)) {
    throw new Error(
      `Expected JSON object mapping fieldName -> {pageIndex,x,y,direction}. Got: ${typeof points}`
    );
  }

  const fieldMap = {};
  for (const [name, p] of stableEntries(points)) {
    if (!p || typeof p !== "object") continue;

    const dirFromInput = normalizeDirection(p.direction);

    fieldMap[name] = {
      pageIndex: Number(p.pageIndex),
      x: Number(p.x),
      y: Number(p.y),

      // Prefer mapper direction if present; else apply --direction if provided
      direction: dirFromInput ?? defaults.direction,

      // Other defaults (global)
      width: defaults.width,
      height: defaults.height,
      fontSize: defaults.fontSize,
      lineHeight: defaults.lineHeight,
      align: defaults.align,
      maxFontSize: defaults.maxFontSize,
      minFontSize: defaults.minFontSize,
      clearBackground: defaults.clearBackground,
    };
  }

  const ts = fieldMapToTs(fieldMap);
  await writeFile(outPath, ts, "utf8");

  console.log(`Generated ${outPath} from ${inPath}`);
  if (defaultDirection) {
    console.log(`Note: default direction applied when missing: ${defaultDirection}`);
  }
}

main().catch((err) => {
  console.error("Generator failed.");
  console.error(err?.stack ?? err);
  process.exit(1);
});
